#!/usr/bin/python

"""
https://github.com/awhyang/simple-3body
"""

import sys
import time
import random
from random import uniform as u
import subprocess as sp

from wand.image import Image
from wand.drawing import Drawing
from wand.color import Color
from wand.display import display


class Vector3():
    def __init__(self, x, y, z):
        self.x=x
        self.y=y
        self.z=z

    def __sub__(self, o):
        return(Vector3(self.x - o.x, self.y - o.y, self.z - o.z))

    def __add__(self, o):
        return(Vector3(self.x + o.x, self.y + o.y, self.z + o.z))

    def divide(self, val):
        return(Vector3(self.x / val, self.y / val, self.z / val))

    def multiply(self, val):
        return(Vector3(self.x * val, self.y * val, self.z * val))

    def round(self):
        return(Vector3(round(self.x, 1), round(self.y, 1), round(self.z, 1)))

    def ret(self):
        return(str(self.x) +' '+ str(self.y) +' '+ str(self.z))

    def magnitude(self):
        return((self.x**2 + self.y**2 + self.z**2) ** 0.5)

    def scale(self, factor):
        self.x =self.x * factor
        self.y = self.y * factor
        self.z = self.z * factor
        return(self)


class Body():
    def __init__(self, M, pos, V, id):
        self.M=M
        self.pos=pos
        self.V=V
        self.id=id

    def getGF(self, o):
        f12 = getF(self, o)
        f12v = (o.pos-self.pos)
        return(f12v.scale((f12/f12v.magnitude())))

    def move(self, F, dt):
        dv = (F.divide(self.M)).multiply(dt)
        dpos = (dv.divide(2) + self.V).multiply(dt)
        self.V = self.V + dv
        self.pos = self.pos + dpos


pos1 = Vector3(u(-100, 100), u(-100, 100), u(0, 100))
pos2 = Vector3(u(-100, 100), u(-100, 100), u(0, 100))
pos3 = Vector3(u(-100, 100), u(-100, 100), u(0, 100))

V1 = Vector3(u(-0.4, 0.4), u(-0.4, 0.4), u(-0.4, 0.4))
V2 = Vector3(u(-0.4, 0.4), u(-0.4, 0.4), u(-0.4, 0.4))
V3 = Vector3(u(-0.4, 0.4), u(-0.4, 0.4), u(-0.4, 0.4))


#pos1 = Vector3(0, 0, 100)
#pos2 = Vector3(0, 300 , 100)
#pos3 = Vector3(300, 0, 50)

#V1 = Vector3(-0.2, 0, -0.05)
#V2 = Vector3(0.4, 0, 0)
#V3 = Vector3(0.1, 0.5, 0.1)


bodyOne = Body(1*10**12, pos1, V1, 'green')
bodyTwo = Body(1*10**12, pos2, V2, 'red')
bodyThree = Body(1*10**12, pos3, V3, 'blue')


def dist(b1, b2):
    return(( ((b1.pos.x-b2.pos.x)**2) + ((b1.pos.y-b2.pos.y)**2) + ((b1.pos.z-b2.pos.z)**2) )**0.5)


def getF(b1, b2):
    G = 6.673*10**-11
    return(G*(b1.M*b2.M)/((dist(b1, b2))**2))


def createImage(b1, b2, b3):
    with Drawing() as draw:
        draw.stroke_width = 2
        draw.fill_color = Color('black')


        bodies=[b1, b2, b3]

        for i in sorted(bodies, key=lambda x:x.pos.z):
            draw.stroke_color = Color(i.id)
            xpos = 960 + i.pos.x
            zpos = (xpos + (i.pos.z + 10)) if i.pos.z > -1000 else (xpos + 100)
            ypos = 540 - i.pos.y

            if zpos < 5000:
                zpos = (xpos + (i.pos.z/2 + 10)) if i.pos.z > 0 else (xpos + 1)
            else:
                zpos = xpos

            draw.circle((xpos, ypos), (zpos+(i.M/10**11), ypos))

        with Image(width=1920, height=1080, background=Color('black')) as image:
            image.save(draw(image), 'desktop.jpg')


def simulate(bodyOne, bodyTwo, bodyThree, dstep, sstep):
    while True:
        for i in range(int(dstep/sstep)):
            F1 = bodyOne.getGF(bodyTwo)+bodyOne.getGF(bodyThree)
            F2 = bodyTwo.getGF(bodyOne)+bodyTwo.getGF(bodyThree)
            F3 = bodyThree.getGF(bodyOne)+bodyThree.getGF(bodyTwo)

            bodyOne.move(F1, 0.01)
            bodyTwo.move(F2, 0.01)
            bodyThree.move(F3, 0.01)



        time.sleep(0.01)

        createImage(bodyOne, bodyTwo, bodyThree)
        sp.Popen(['feh', '--bg-fill', 'desktop.jpg'])

        sys.stdout.write('\r'+'Body One: '+str(bodyOne.pos.round().ret())+'  Body Two: '+str(bodyTwo.pos.round().ret())+'  Body Three: '+str(bodyThree.pos.round().ret()) + ' Velocity: ' + str(round(bodyOne.V.magnitude(), 3)) +' '+ str(round(bodyTwo.V.magnitude(), 3)) +' '+ str(round(bodyTwo.V.magnitude(), 3)))




simulate(bodyOne, bodyTwo, bodyThree, 3, 0.01)
